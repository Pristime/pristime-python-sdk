# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Pristime-API-Key` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class Metrics(BaseModel):
    """
    Comprehensive financial and operational metrics from workforce scheduling optimization.  These metrics provide detailed insights into the optimization's effectiveness, including revenue generated, costs incurred, and operational statistics. Essential for understanding the business impact and quality of scheduling decisions.  **Metric Categories:**  **Primary Metrics:** - profit: Overall optimization value (revenue - costs) - partial_profit: Profit excluding period-closing adjustments  **Revenue Sources:** - assignment_revenue: Value from assigning workers to high-value shifts - demand_revenue: Revenue from meeting staffing demand requirements - preferred_time_revenue: Bonus for scheduling during preferred hours - continuity_revenue: Value from maintaining worker schedule consistency - skill_revenue: Revenue from matching skilled workers with shifts that require their skills. - pto_time_revenue: Value from optimally scheduling paid time off  **Cost Factors:** - assignment_cost: Cost of worker assignments - overtime_cost: Cost of overtime hours - unpreferred_time_cost: Penalty for scheduling during unpreferred hours - idle_time_cost: Cost of gaps between worker shifts - variable_costs: Sum of all costs above  **Balance Management:** - period_closing_profit: Flextime and overtime balance adjustments - flextime_balance_negative_revenue: Revenue from accumulated time credit - flextime_balance_positive_cost: Cost of accumulated time credits - overtime_balance_cost: Cost of overtime balance  **Operational Statistics:** - assigned_time: Total minutes of productive work scheduled - overtime: Minutes of premium overtime scheduled - recovered_time: Overtime taken as PTO instead of cash payment
    """ # noqa: E501
    start_date: date = Field(description="First date included in the metrics calculation period.")
    end_date: date = Field(description="Last date included in the metrics calculation period.")
    profit: Union[StrictFloat, StrictInt] = Field(description="Total optimization value (all revenue minus all costs). Primary measure of scheduling effectiveness and business impact.")
    partial_profit: Union[StrictFloat, StrictInt] = Field(description="Core profit excluding period-closing balance adjustments. Shows operational scheduling value without accounting complexities.")
    pto_time_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue generated from optimally scheduling paid time off periods. Balances worker satisfaction with operational needs.")
    assignment_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue from assigning workers to shifts based on shift value and worker suitability. Core revenue from successful matches.")
    skill_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue bonus from matching workers with compatible shift requirements, skills, or preferences. Rewards optimal worker-shift pairing.")
    continuity_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue from maintaining consistent worker schedules and minimizing assignment changes. Values schedule stability for worker satisfaction.")
    demand_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue generated from meeting staffing demand requirements. Measures success in providing adequate coverage for business needs.")
    preferred_time_revenue: Union[StrictFloat, StrictInt] = Field(description="Bonus revenue from scheduling workers during their preferred time periods. Balances worker preferences with operational requirements.")
    variable_costs: Union[StrictFloat, StrictInt] = Field(description="Additional operational costs incurred from scheduling decisions. Includes dynamic costs that vary with assignment patterns.")
    overtime_cost: Union[StrictFloat, StrictInt] = Field(description="Premium labor costs for overtime hours beyond regular contract time. Reflects the additional expense of extended work periods.")
    has_exceeded_preferred_max_consecutive_workdays_limit_cost: Union[StrictFloat, StrictInt] = Field(description="Penalty cost when workers exceed preferred maximum consecutive workdays.")
    idle_time_cost: Union[StrictFloat, StrictInt] = Field(description="Cost of unproductive time gaps between worker shifts. Encourages efficient schedule compactness while respecting break requirements.")
    assignment_cost: Union[StrictFloat, StrictInt] = Field(description="Base labor costs for worker assignments including wages, benefits, and administrative overhead. Core cost of workforce utilization.")
    unpreferred_time_cost: Union[StrictFloat, StrictInt] = Field(description="Penalty for scheduling workers during periods they marked as unpreferred. Balances operational needs with worker satisfaction.")
    period_closing_profit: Union[StrictFloat, StrictInt] = Field(description="Profit adjustment for flextime and overtime balance management at period boundaries. Handles accounting for accumulated time credits/debts.")
    flextime_balance_negative_revenue: Union[StrictFloat, StrictInt] = Field(description="Revenue from workers making up time debt (negative flextime balance). Helps ensure contract hour obligations are met.")
    flextime_balance_positive_cost: Union[StrictFloat, StrictInt] = Field(description="Cost of accumulated worker time credits (positive flextime balance). Represents future time-off obligations or premium payments.")
    overtime_balance_cost: Union[StrictFloat, StrictInt] = Field(description="Cost associated with managing overtime balances and accumulated overtime compensation. Tracks overtime liability management.")
    assigned_time: Union[StrictFloat, StrictInt] = Field(description="Total minutes of productive work time assigned to workers. Core measure of workforce utilization and operational capacity.")
    overtime: Union[StrictFloat, StrictInt] = Field(description="Total minutes of overtime scheduled beyond regular contract hours. Indicates reliance on premium labor to meet demands.")
    recovered_time: Union[StrictFloat, StrictInt] = Field(description="Total minutes of overtime taken as paid time off instead of cash payment. Shows flexibility in overtime compensation management.")
    __properties: ClassVar[List[str]] = ["start_date", "end_date", "profit", "partial_profit", "pto_time_revenue", "assignment_revenue", "skill_revenue", "continuity_revenue", "demand_revenue", "preferred_time_revenue", "variable_costs", "overtime_cost", "has_exceeded_preferred_max_consecutive_workdays_limit_cost", "idle_time_cost", "assignment_cost", "unpreferred_time_cost", "period_closing_profit", "flextime_balance_negative_revenue", "flextime_balance_positive_cost", "overtime_balance_cost", "assigned_time", "overtime", "recovered_time"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Metrics from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Metrics from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in Metrics) in the input: " + _key)

        _obj = cls.model_validate({
            "start_date": obj.get("start_date"),
            "end_date": obj.get("end_date"),
            "profit": obj.get("profit"),
            "partial_profit": obj.get("partial_profit"),
            "pto_time_revenue": obj.get("pto_time_revenue"),
            "assignment_revenue": obj.get("assignment_revenue"),
            "skill_revenue": obj.get("skill_revenue"),
            "continuity_revenue": obj.get("continuity_revenue"),
            "demand_revenue": obj.get("demand_revenue"),
            "preferred_time_revenue": obj.get("preferred_time_revenue"),
            "variable_costs": obj.get("variable_costs"),
            "overtime_cost": obj.get("overtime_cost"),
            "has_exceeded_preferred_max_consecutive_workdays_limit_cost": obj.get("has_exceeded_preferred_max_consecutive_workdays_limit_cost"),
            "idle_time_cost": obj.get("idle_time_cost"),
            "assignment_cost": obj.get("assignment_cost"),
            "unpreferred_time_cost": obj.get("unpreferred_time_cost"),
            "period_closing_profit": obj.get("period_closing_profit"),
            "flextime_balance_negative_revenue": obj.get("flextime_balance_negative_revenue"),
            "flextime_balance_positive_cost": obj.get("flextime_balance_positive_cost"),
            "overtime_balance_cost": obj.get("overtime_balance_cost"),
            "assigned_time": obj.get("assigned_time"),
            "overtime": obj.get("overtime"),
            "recovered_time": obj.get("recovered_time")
        })
        return _obj


