# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Pristime-API-Key` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from pristime_sdk.models.continuous_work_duration_before_break import ContinuousWorkDurationBeforeBreak
from pristime_sdk.models.work_duration import WorkDuration
from typing import Optional, Set
from typing_extensions import Self

class ShiftCreationSettings(BaseModel):
    """
    Configuration for automatically creating shifts to fulfill staffing demands.  When a demand cannot be fully satisfied by existing shifts, the system can automatically generate new shifts with these specifications. This is useful for:  - **Dynamic scheduling**: Create shifts on-demand based on actual staffing needs - **Gap filling**: Generate shifts to cover periods with insufficient existing coverage - **Uniform coverage**: Ensure consistent shift characteristics across time periods - **Skill-specific coverage**: Create shifts that require specific worker qualifications  **Important:** All created shifts must be compatible with the parent demand's requirements. For example, if the demand requires shifts with tag \"ICU\", the shift creation settings must include \"ICU\" in their tags.
    """ # noqa: E501
    timezone: StrictStr = Field(description="Timezone for all automatically created shifts. Should typically match the demand's timezone and your business location.")
    required_skills: Optional[List[StrictStr]] = Field(default=None, description="Skills, certifications, or qualifications required for workers to be assigned to created shifts. Must be a superset of the demand's required_skills.")
    tags: Optional[List[StrictStr]] = Field(default=None, description="Descriptive tags that will be applied to all created shifts. Must be a superset of the demand's required_shift_tags to ensure compatibility.")
    day_boundary_offset_minutes: Optional[StrictInt] = Field(default=0, description="Day boundary adjustment for created shifts, useful for night shift operations. Positive values shift the day end later (e.g., +120 = day ends at 2:00 AM).")
    break_minutes: StrictInt = Field(description="Duration in minutes for break periods that will be automatically added to created shifts. Breaks are unpaid time subtracted from work hours.")
    work_duration: WorkDuration
    continuous_work_duration_before_break: ContinuousWorkDurationBeforeBreak
    __properties: ClassVar[List[str]] = ["timezone", "required_skills", "tags", "day_boundary_offset_minutes", "break_minutes", "work_duration", "continuous_work_duration_before_break"]

    @field_validator('break_minutes')
    def break_minutes_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set([30, 60]):
            raise ValueError("must be one of enum values (30, 60)")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ShiftCreationSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of work_duration
        if self.work_duration:
            _dict['work_duration'] = self.work_duration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of continuous_work_duration_before_break
        if self.continuous_work_duration_before_break:
            _dict['continuous_work_duration_before_break'] = self.continuous_work_duration_before_break.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ShiftCreationSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in ShiftCreationSettings) in the input: " + _key)

        _obj = cls.model_validate({
            "timezone": obj.get("timezone"),
            "required_skills": obj.get("required_skills"),
            "tags": obj.get("tags"),
            "day_boundary_offset_minutes": obj.get("day_boundary_offset_minutes") if obj.get("day_boundary_offset_minutes") is not None else 0,
            "break_minutes": obj.get("break_minutes"),
            "work_duration": WorkDuration.from_dict(obj["work_duration"]) if obj.get("work_duration") is not None else None,
            "continuous_work_duration_before_break": ContinuousWorkDurationBeforeBreak.from_dict(obj["continuous_work_duration_before_break"]) if obj.get("continuous_work_duration_before_break") is not None else None
        })
        return _obj


