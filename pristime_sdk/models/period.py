# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Authorization` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Period(BaseModel):
    """
    A time period with start and end datetimes, fundamental to workforce scheduling operations.  This class represents any time interval in the scheduling system and is used throughout for shifts, availability windows, breaks, PTO periods, and demands. It provides essential time manipulation methods for scheduling optimization.  **Critical Timing Convention - Half-Open Intervals:** - The start_datetime is **included** and the end_datetime is **excluded** [start, end) - This prevents overlaps and gaps when periods are adjacent - Example: Shift 10:00-18:00 includes 10:00:00 but excludes 18:00:00 exactly - Adjacent periods: 09:00-12:00 and 12:00-17:00 have no overlap or gap  **Common Usage in Scheduling:** - **Work Shifts**: Define when a worker is scheduled to work - **Availability**: When a worker is available for assignment - **Breaks**: Unpaid periods within shifts (subtracted from work time)  **Time Precision Rules:** - All datetimes must be whole minutes (seconds=0, microseconds=0)  **Key Features:** - Overlap detection and calculation - Period subtraction (for break handling) - Containment checking (worker availability vs. shift times) - Duration calculation in minutes
    """ # noqa: E501
    start_datetime: datetime = Field(description="Beginning of the time period (inclusive). This exact moment is included in the period. Must be rounded to the nearest minute for scheduling precision.")
    end_datetime: datetime = Field(description="End of the time period (exclusive). This exact moment is NOT included in the period, allowing periods to be adjacent without overlap. Must be rounded to the nearest minute.")
    __properties: ClassVar[List[str]] = ["start_datetime", "end_datetime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Period from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Period from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in Period) in the input: " + _key)

        _obj = cls.model_validate({
            "start_datetime": obj.get("start_datetime"),
            "end_datetime": obj.get("end_datetime")
        })
        return _obj


