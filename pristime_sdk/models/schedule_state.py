# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Pristime-API-Key` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from pristime_sdk.models.demand import Demand
from pristime_sdk.models.schedule_job_config import ScheduleJobConfig
from pristime_sdk.models.scheduling_period import SchedulingPeriod
from pristime_sdk.models.shift import Shift
from pristime_sdk.models.worker import Worker
from typing import Optional, Set
from typing_extensions import Self

class ScheduleState(BaseModel):
    """
    Complete workforce scheduling optimization request.  This is the main payload for scheduling jobs, containing all the information needed to optimize shift assignments across your workforce. The optimization engine will assign shifts to workers while respecting availability, skills, labor constraints, and business rules to meet staffing demands efficiently.  **Typical Workflow:** 1. Define the scheduling period and timezone 2. Add your workers with their availability and skills 3. Add shifts to be assigned (existing or new) 4. Specify staffing demands (how many workers needed when) 5. Add any custom constraints 6. Submit for optimization 7. Receive optimized shift assignments
    """ # noqa: E501
    scheduling_period: SchedulingPeriod
    workers: Optional[List[Worker]] = Field(default=None, description="Your staff members available for shift assignment. Include their availability, skills, work constraints, and contract details.")
    shifts: Optional[List[Shift]] = Field(default=None, description="Work shifts to be optimized. Can include assigned and unassigned shifts.")
    demands: Optional[List[Demand]] = Field(default=None, description="Staffing requirements over time - specify how many workers with certain skills you need at different times.")
    config: Optional[ScheduleJobConfig] = None
    __properties: ClassVar[List[str]] = ["scheduling_period", "workers", "shifts", "demands", "config"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ScheduleState from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of scheduling_period
        if self.scheduling_period:
            _dict['scheduling_period'] = self.scheduling_period.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in workers (list)
        _items = []
        if self.workers:
            for _item_workers in self.workers:
                if _item_workers:
                    _items.append(_item_workers.to_dict())
            _dict['workers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in shifts (list)
        _items = []
        if self.shifts:
            for _item_shifts in self.shifts:
                if _item_shifts:
                    _items.append(_item_shifts.to_dict())
            _dict['shifts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in demands (list)
        _items = []
        if self.demands:
            for _item_demands in self.demands:
                if _item_demands:
                    _items.append(_item_demands.to_dict())
            _dict['demands'] = _items
        # override the default output from pydantic by calling `to_dict()` of config
        if self.config:
            _dict['config'] = self.config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ScheduleState from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in ScheduleState) in the input: " + _key)

        _obj = cls.model_validate({
            "scheduling_period": SchedulingPeriod.from_dict(obj["scheduling_period"]) if obj.get("scheduling_period") is not None else None,
            "workers": [Worker.from_dict(_item) for _item in obj["workers"]] if obj.get("workers") is not None else None,
            "shifts": [Shift.from_dict(_item) for _item in obj["shifts"]] if obj.get("shifts") is not None else None,
            "demands": [Demand.from_dict(_item) for _item in obj["demands"]] if obj.get("demands") is not None else None,
            "config": ScheduleJobConfig.from_dict(obj["config"]) if obj.get("config") is not None else None
        })
        return _obj


