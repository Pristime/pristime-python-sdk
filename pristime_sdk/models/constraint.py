# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Authorization` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Constraint(BaseModel):
    """
    Custom business rule that limits which shifts can be assigned to which workers.  Constraints allow you to enforce specific business requirements that go beyond the basic availability and skills matching. They work by limiting the total number of shifts that can be assigned from a specific set to a specific group of workers.  **Common Use Cases:** - **Exclusive assignments**: Ensure only one worker from a group can be assigned to critical shifts - **Load balancing**: Distribute high-demand shifts fairly across qualified workers - **Specialization limits**: Prevent workers from being over-assigned to specialized roles - **Cross-training**: Ensure multiple workers can cover important shift types - **Conflict resolution**: Handle situations where certain workers shouldn't work together  **How it works:** The constraint specifies a maximum number of shifts from `caller_shift_ids` that can be assigned to workers in `caller_worker_ids`. For example, with max_assigned=1: - Only 1 of the specified shifts can be assigned to any of the specified workers - This could ensure exclusive coverage or prevent resource conflicts  **Example:** To ensure only one supervisor works weekend nights: - caller_shift_ids: [weekend_night_shift_1, weekend_night_shift_2] - caller_worker_ids: [supervisor_alice, supervisor_bob] - max_assigned: 1
    """ # noqa: E501
    caller_shift_ids: Optional[List[StrictStr]] = Field(default=None, description="List of shift IDs that this constraint applies to. These are the shifts that will be limited in their assignment to the specified workers.")
    caller_worker_ids: Optional[List[StrictStr]] = Field(default=None, description="List of worker IDs that this constraint applies to. These are the workers who are subject to the assignment limitation for the specified shifts.")
    max_assigned: Optional[StrictInt] = Field(default=1, description="Maximum number of shifts (from caller_shift_ids) that can be assigned to any combination of workers (from caller_worker_ids). Use 1 for exclusive assignment, higher numbers for load distribution.")
    __properties: ClassVar[List[str]] = ["caller_shift_ids", "caller_worker_ids", "max_assigned"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Constraint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Constraint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in Constraint) in the input: " + _key)

        _obj = cls.model_validate({
            "caller_shift_ids": obj.get("caller_shift_ids"),
            "caller_worker_ids": obj.get("caller_worker_ids"),
            "max_assigned": obj.get("max_assigned") if obj.get("max_assigned") is not None else 1
        })
        return _obj


