# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Pristime-API-Key` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class DayCosts(BaseModel):
    """
    Daily cost parameters for different types of work time used in optimization calculations.  These costs influence how the optimizer assigns shifts by making certain work patterns more or less economically attractive. Higher costs discourage the optimizer from choosing those assignments, while lower costs make them more appealing.  **Business Impact:** - Controls overtime usage (higher overtime costs = less overtime assignments) - Manages idle time between shifts (higher idle costs = more efficient scheduling) - Balances expected vs actual work hours (flextime cost management)
    """ # noqa: E501
    per_expected_hour: Optional[StrictInt] = Field(default=0, description="Cost per hour of expected work time. Used when worker has guaranteed hours that must be paid regardless of actual assignments.")
    per_flextime_positive_hour: Optional[StrictInt] = Field(default=8, description="Cost per hour when worker exceeds their standard daily hours (positive flextime). Higher values discourage over-scheduling on individual days.")
    per_overtime_hour: Optional[StrictInt] = Field(default=50, description="Cost per hour of overtime work beyond regular hours. Set higher to limit overtime usage to only high-value shifts.")
    per_assigned_hour: Optional[StrictInt] = Field(default=0, description="Base cost per hour for any assigned shift work. Represents the fundamental cost of having a worker on duty.")
    per_idle_hour_between_shifts: Optional[StrictInt] = Field(default=1, description="Cost per hour of paid idle time between shifts on the same day. Higher values encourage tighter scheduling with fewer gaps.")
    per_undertime_hour: Optional[StrictInt] = Field(default=10, description="Small cost per hour when worker is scheduled less than expected. Helps ensure workers get their expected hours when possible.")
    __properties: ClassVar[List[str]] = ["per_expected_hour", "per_flextime_positive_hour", "per_overtime_hour", "per_assigned_hour", "per_idle_hour_between_shifts", "per_undertime_hour"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DayCosts from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DayCosts from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in DayCosts) in the input: " + _key)

        _obj = cls.model_validate({
            "per_expected_hour": obj.get("per_expected_hour") if obj.get("per_expected_hour") is not None else 0,
            "per_flextime_positive_hour": obj.get("per_flextime_positive_hour") if obj.get("per_flextime_positive_hour") is not None else 8,
            "per_overtime_hour": obj.get("per_overtime_hour") if obj.get("per_overtime_hour") is not None else 50,
            "per_assigned_hour": obj.get("per_assigned_hour") if obj.get("per_assigned_hour") is not None else 0,
            "per_idle_hour_between_shifts": obj.get("per_idle_hour_between_shifts") if obj.get("per_idle_hour_between_shifts") is not None else 1,
            "per_undertime_hour": obj.get("per_undertime_hour") if obj.get("per_undertime_hour") is not None else 10
        })
        return _obj


