# coding: utf-8

"""
    Pristime Workforce Scheduling API

             ## Pristime Workforce Scheduling API          The Pristime Scheduling API lets clients provide workers, shifts,         and constraints, and returns optimized schedules.          ## Authentication          All endpoints require an API key in the `Pristime-API-Key` header.          ## Support          For technical support, contact us at antoine.hachez@pristime.com         

    The version of the OpenAPI document: 2.0.0
    Contact: antoine.hachez@pristime.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from pristime_sdk.models.period import Period
from pristime_sdk.models.shift_assignment import ShiftAssignment
from pristime_sdk.models.shift_revenues import ShiftRevenues
from typing import Optional, Set
from typing_extensions import Self

class Shift(BaseModel):
    """
    Represents a work shift that can be assigned to workers during scheduling optimization.  A shift defines a specific time period requiring worker coverage, including timing, location, required skills, break periods, and assignment status. Shifts can be: - **Unassigned**: Need a worker (will be optimally assigned) - **Pre-assigned**: Already have a worker but can be reassigned if beneficial - **Locked**: Have a worker and cannot be changed  **Day Assignment Rules for Night Shifts:** - The entire shift is associated with the day it **starts**, not when it ends - Uses the `day_boundary_offset_minutes` parameter for custom day boundaries - Example: Night shift 22:00 Monday â†’ 06:00 Tuesday is a \"Monday shift\" - Workers with Monday availability can work this shift even if unavailable Tuesday  **Timing Conventions:** - Start time is included, end time is excluded [start_time, end_time) - All times must be whole minutes (no seconds or milliseconds) - Break periods are subtracted from total time to get actual work duration  **Assignment Optimization:** - Skills matching (worker must have all required skills) - Availability checking (no conflicts with unavailable periods) - Cost/revenue optimization (considers worker rates and shift value) - Constraint satisfaction (respects break requirements, consecutive day limits, etc.)
    """ # noqa: E501
    start_datetime: datetime = Field(description="Beginning of the time period (inclusive). This exact moment is included in the period. Must be rounded to the nearest minute for scheduling precision.")
    end_datetime: datetime = Field(description="End of the time period (exclusive). This exact moment is NOT included in the period, allowing periods to be adjacent without overlap. Must be rounded to the nearest minute.")
    timezone: StrictStr = Field(description="Timezone for interpreting start_datetime and end_datetime")
    id: Optional[StrictStr] = None
    label: Optional[StrictStr] = None
    revenues: Optional[ShiftRevenues] = None
    revenue: Optional[StrictInt] = Field(default=0, description="Additional fixed revenue value for this specific shift, added to calculated hourly revenues.")
    breaks: Optional[List[Period]] = Field(default=None, description="Unpaid break periods during the shift (lunch, rest breaks). Breaks are subtracted from total shift duration to calculate actual work time. Must be entirely within the shift timeframe.")
    tags: Optional[List[StrictStr]] = Field(default=None, description="Descriptive labels for the shift type, location, or characteristics. Used to match shifts with demand requirements.")
    required_skills: Optional[List[StrictStr]] = Field(default=None, description="Skills, certifications, or qualifications that a worker must possess to be assigned to this shift. Workers without these skills will be ineligible.")
    assignment: Optional[ShiftAssignment] = None
    preceding_shift_id: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["start_datetime", "end_datetime", "timezone", "id", "label", "revenues", "revenue", "breaks", "tags", "required_skills", "assignment", "preceding_shift_id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Shift from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of revenues
        if self.revenues:
            _dict['revenues'] = self.revenues.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in breaks (list)
        _items = []
        if self.breaks:
            for _item_breaks in self.breaks:
                if _item_breaks:
                    _items.append(_item_breaks.to_dict())
            _dict['breaks'] = _items
        # override the default output from pydantic by calling `to_dict()` of assignment
        if self.assignment:
            _dict['assignment'] = self.assignment.to_dict()
        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if label (nullable) is None
        # and model_fields_set contains the field
        if self.label is None and "label" in self.model_fields_set:
            _dict['label'] = None

        # set to None if preceding_shift_id (nullable) is None
        # and model_fields_set contains the field
        if self.preceding_shift_id is None and "preceding_shift_id" in self.model_fields_set:
            _dict['preceding_shift_id'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Shift from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "start_datetime": obj.get("start_datetime"),
            "end_datetime": obj.get("end_datetime"),
            "timezone": obj.get("timezone"),
            "id": obj.get("id"),
            "label": obj.get("label"),
            "revenues": ShiftRevenues.from_dict(obj["revenues"]) if obj.get("revenues") is not None else None,
            "revenue": obj.get("revenue") if obj.get("revenue") is not None else 0,
            "breaks": [Period.from_dict(_item) for _item in obj["breaks"]] if obj.get("breaks") is not None else None,
            "tags": obj.get("tags"),
            "required_skills": obj.get("required_skills"),
            "assignment": ShiftAssignment.from_dict(obj["assignment"]) if obj.get("assignment") is not None else None,
            "preceding_shift_id": obj.get("preceding_shift_id")
        })
        return _obj


